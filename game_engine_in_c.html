<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Writing a Game Engine in C</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="writing-a-game-engine-in-c">Writing a Game Engine in C</h1>
<p>This is a kind of unstructured log of the process of writing a game engine in C, using <a href="https://www.raylib.com/">raylib</a> as the backend. As a disclaimer, I have no idea what I am doing or what best practices are.</p>
<h2 id="day-1-allocator">Day 1: Allocator</h2>
<p>The first thing we need to do is figure out how the game engine is going to be structured.</p>
<p>My initial thoughts are:</p>
<ul>
<li>We divide the game into 'scenes', which are loaded and unloaded according to some logic (like when a user presses the 'level 0' button, we load the level 0 scene).</li>
<li>Each scene contains a number of 'prefabs'. When we load a scene, we 'instantiate' these prefabs into game objects, which are the entities in the scene. This is also nice because then we can instantiate more prefabs while the scene is going.</li>
<li>Each prefab contains some information - the initial transform of the entity, whether it has a model, what the path to the model is etc.. We use this information to construct an independent GameObject.</li>
<li>Each prefab (and thus GameObject) has some 'scripts' associated with it. These scripts function like callbacks (? terminology confusing idk if I am using that right), in the sense that each script can implement, for example, an <code>onUpdate</code> function that is called every frame, or an <code>onInit</code> function that is called on GameObject creation.</li>
</ul>
<p>This is a nice rough idea of how we want things to be structured. One thing that would be nice though is to be able to allocate memory/load models etc. that are automatically freed/unloaded when the current scene is closed. We are going to need to load models/allocate memory for GameObjects whenever a scene is loaded, and we only want to free/unload them when the scene is closed.</p>
<p>So the first bit of code we can write is a simple allocator that keeps track of memory allocations/loaded models.</p>
<p>This is the interface I went with (in <code>sceneallocator.h</code>):</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _FLUX_SCENEALLOCATOR_H_</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _FLUX_SCENEALLOCATOR_H_</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;raylib.h&quot;</span></span>

<span class="hljs-comment">// initializes the scene allocator for the current scene (so should be called every scene load)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">flux_init_scene_allocator</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;

<span class="hljs-comment">// closes the scene allocator for the current scene (so should be called every scene close)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">flux_close_scene_allocator</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;

<span class="hljs-comment">// allocates some heap space that will be cleared on scene close</span>
<span class="hljs-type">void</span>* <span class="hljs-title function_">flux_scene_alloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> sz)</span>;

<span class="hljs-comment">// loads a model that will be cleared on scene close</span>
Model <span class="hljs-title function_">flux_scene_load_model</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>So, we would call <code>flux_init_scene_allocator</code> whenever we load a scene, and <code>flux_close_scene_allocator</code> whenever we close a scene. Then, we can use <code>flux_scene_alloc</code> and <code>flux_scene_load_model</code> to allocate memory/load models without having to worry about unloading/freeing (because this is done in <code>flux_close_scene_allocator</code>).</p>
<p>The implementation is fairly simple. We store allocations and models in contiguous arrays. So, in <code>sceneallocator.c</code>:</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;raylib.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;raymath.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gameobject.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sceneallocator.h&quot;</span></span>

<span class="hljs-comment">// stores all the allocations of the current scene in resizable array</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span>** allocations = <span class="hljs-literal">NULL</span>;
<span class="hljs-comment">// number of active allocations</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> n_allocations = <span class="hljs-number">0</span>;
<span class="hljs-comment">// size of the allocations array (n_allocations may be less than allocations_size)</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> allocations_size = <span class="hljs-number">0</span>;

<span class="hljs-comment">// similarly for models</span>
<span class="hljs-type">static</span> Model* models = <span class="hljs-literal">NULL</span>;
<span class="hljs-type">static</span> <span class="hljs-type">int</span> n_models = <span class="hljs-number">0</span>;
<span class="hljs-type">static</span> <span class="hljs-type">int</span> models_size = <span class="hljs-number">0</span>;
</code></pre>
<p>This lets us write hacky hardcoded grow-able arrays for allocations and models. It would probably be smart to write a general resizable array at some point, because we will want to be able to load shaders/textures etc in the same way.</p>
<p>First we implement <code>flux_init_scene_allocator</code>. I will probably want to clean this up in the future, but this works for now:</p>
<pre><code class="language-c"><span class="hljs-comment">// initializes the scene allocator for the current scene (so should be called every scene load)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">flux_init_scene_allocator</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
    <span class="hljs-comment">// allocations and models must be NULL</span>
    <span class="hljs-comment">// if not, then something bad happened</span>
    assert((<span class="hljs-literal">NULL</span> == allocations) &amp;&amp; (<span class="hljs-literal">NULL</span> == models) &amp;&amp; <span class="hljs-string">&quot;was fluxCloseSceneAllocator called on scene close?&quot;</span>);
    <span class="hljs-comment">// set number of allocations and models to 0</span>
    n_allocations = <span class="hljs-number">0</span>;
    n_models = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// and the initial size of the allocations and models arrays to be 10</span>
    allocations_size = <span class="hljs-number">10</span>;
    models_size = <span class="hljs-number">10</span>;
    <span class="hljs-comment">// malloc accordingly</span>
    assert(allocations = (<span class="hljs-type">void</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span>*) * allocations_size));
    assert(models = (<span class="hljs-type">void</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Model) * models_size));
}
</code></pre>
<p>For <code>flux_close_scene_allocator</code> we want to free all the allocations and models by looping through the active allocations/models:</p>
<pre><code class="language-c"><span class="hljs-comment">// closes the scene allocator for the current scene (so should be called every scene close)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">flux_close_scene_allocator</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
    assert((n_allocations &gt;= <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;n_allocations was less than 0???&quot;</span>);
    assert((n_allocations &lt; allocations_size) &amp;&amp; <span class="hljs-string">&quot;n_allocations is less than allocations_size!&quot;</span>);
    assert((n_models &gt;= <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;n_models was less than 0???&quot;</span>);
    assert((n_models &lt; models_size) &amp;&amp; <span class="hljs-string">&quot;n_models is less than models_size!&quot;</span>);
    <span class="hljs-comment">// loop through active allocations and free the memory</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n_allocations; i++){
        <span class="hljs-built_in">free</span>(allocations[i]);
    }
    <span class="hljs-comment">// finally free the allocations array and set to NULL</span>
    <span class="hljs-built_in">free</span>(allocations); allocations = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// loop through active models and free the Model</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n_models; i++){
        UnloadModel(models[i]);
    }
    <span class="hljs-built_in">free</span>(models); models = <span class="hljs-literal">NULL</span>;
}
</code></pre>
<p>Finally, for the allocation and model loading methods, we do the hacky hardcoded grow-able array stuff:</p>
<pre><code class="language-c"><span class="hljs-comment">// allocates some heap space that will be cleared on scene close</span>
<span class="hljs-type">void</span>* <span class="hljs-title function_">flux_scene_alloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> sz)</span>{
    assert((n_allocations &gt;= <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;n_allocations was less than 0???&quot;</span>);
    <span class="hljs-comment">// if we are out of space, we must grow the array</span>
    <span class="hljs-keyword">if</span> (n_allocations &gt;= allocations_size){
        assert((allocations_size &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;allocations_size should never be less than 1!&quot;</span>);
        <span class="hljs-comment">// double the size of the allocations array</span>
        allocations_size *= <span class="hljs-number">2</span>;
        <span class="hljs-comment">// realloc accordingly</span>
        assert(allocations = <span class="hljs-built_in">realloc</span>(allocations,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span>*) * allocations_size));
        assert((n_allocations &lt; allocations_size) &amp;&amp; <span class="hljs-string">&quot;n_allocations was still bigger than allocations_size after resize!&quot;</span>);
    }
    <span class="hljs-comment">// get the pointer to be returned</span>
    <span class="hljs-type">void</span>* out; assert(out = (<span class="hljs-type">void</span>*)<span class="hljs-built_in">malloc</span>(sz));
    <span class="hljs-comment">// store this pointer in the correct place in allocations</span>
    allocations[n_allocations] = out;
    <span class="hljs-comment">// and then increment n_allocations</span>
    n_allocations++;
    <span class="hljs-comment">// finally return the malloced data</span>
    <span class="hljs-keyword">return</span> out;
}

Model <span class="hljs-title function_">flux_scene_load_model</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>{
    assert((n_models &gt;= <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;n_models was less than 0???&quot;</span>);
    <span class="hljs-comment">// if we are out of space, we must grow the array</span>
    <span class="hljs-keyword">if</span> (n_models &gt;= models_size){
        assert((models_size &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;models_size should never be less than 1!&quot;</span>);
        <span class="hljs-comment">// double the size of the models array</span>
        models_size *= <span class="hljs-number">2</span>;
        <span class="hljs-comment">// realloc accordingly</span>
        assert(models = <span class="hljs-built_in">realloc</span>(models,<span class="hljs-keyword">sizeof</span>(Model) * models_size));
        assert((n_models &lt; models_size) &amp;&amp; <span class="hljs-string">&quot;n_models was still bigger than models_size after resize!&quot;</span>);
    }
    <span class="hljs-comment">// get the model to be returned</span>
    Model out = LoadModel(path);
    <span class="hljs-comment">// store this model in the correct place in models</span>
    models[n_models] = out;
    <span class="hljs-comment">// and then increment n_models</span>
    n_models++;
    <span class="hljs-comment">// finally return the loaded model</span>
    <span class="hljs-keyword">return</span> out;
}
</code></pre>
<p>Next up: Scripts!</p>
<h2 id="day-2-scripts">Day 2: Scripts</h2>
<p>Ok, so we need a way to write scripts that will do stuff with game objects. We should be able to attach an arbitrary script to an arbitrary game object. If we were writing this in C++, we would maybe have each script inherit from a base <code>script</code> class and then use virtual dispatch.</p>
<p>But we aren't doing that. So, lets do a hacky thing with macros and a python script. This keeps us in C world, but also should be faster than virtual dispatch - we can do everything with switch statements.</p>
<p>My basic idea is that I want to be able to write a script (for example in <code>my_script.c</code>) where I can just fill in certain callback functions. For example, something like</p>
<pre><code class="language-c"><span class="hljs-type">void</span> <span class="hljs-title function_">onInit</span><span class="hljs-params">(...)</span>{
    <span class="hljs-comment">// do stuff</span>
}

<span class="hljs-type">void</span> <span class="hljs-title function_">onUpdate</span><span class="hljs-params">(...)</span>{
    <span class="hljs-comment">// do stuff</span>
}
</code></pre>
<p>and then in some way attach this script to a gameobject and have the <code>onUpdate</code> method automatically called every frame etc..</p>
<p>So, lets do a hacky macro thing. In <code>fluxScript.h</code>, I have:</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gameobject.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> fluxConcat_(X,Y) X ## _ ## Y</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> fluxConcat(X,Y) fluxConcat_(X,Y)</span>

<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> SCRIPT</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> fluxCallback static inline void</span>

<span class="hljs-meta">#<span class="hljs-keyword">define</span> onUpdate fluxConcat(SCRIPT,fluxCallback_onUpdate)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> afterUpdate fluxConcat(SCRIPT,fluxCallback_afterUpdate)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> onInit fluxConcat(SCRIPT,fluxCallback_onInit)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> onDestroy fluxConcat(SCRIPT,fluxCallback_onDestroy)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> onDraw fluxConcat(SCRIPT,fluxCallback_onDraw)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> onDraw2D fluxConcat(SCRIPT,fluxCallback_onDraw2D)</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> script_data struct fluxConcat(SCRIPT,fluxData)</span>

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>The idea is that when I want to write a script, say <code>my_script.c</code>, I first <code>#define SCRIPT my_script</code> and then <code>#include &quot;fluxScript.h&quot;</code>. Then, I can write functions like:</p>
<pre><code class="language-c">fluxCallback <span class="hljs-title function_">onUpdate</span><span class="hljs-params">(...)</span>{
    ...
}
</code></pre>
<p>which will be mangled accordingly. So, for example:</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> SCRIPT test</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fluxScript.h&quot;</span></span>

script_data{
    <span class="hljs-type">int</span> x;
};

fluxCallback <span class="hljs-title function_">onInit</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{
    data-&gt;x = <span class="hljs-number">0</span>;
}

fluxCallback <span class="hljs-title function_">onUpdate</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{
    data-&gt;x++;
}
</code></pre>
<p>Here, <code>script_data</code> is data associated with each instance of a script. We want a way to manage all of this automatically. We can do this using a hacky python preprocessing script.</p>
<p>The basic idea is that we discover all scripts (by making the user have all of them in the same place), then gather them all into a single file and then write wrappers to let us do a kind of virtual dispatch on a generic <code>struct script</code> thing.</p>
<p>In the python script we first need to specify all the possible callbacks. I'm doing this in a global variable because I am lazy, but this will probably change in the future as we want to add more callbacks.</p>
<p>Starting off</p>
<pre><code class="language-python"><span class="hljs-keyword">import</span> sys
<span class="hljs-keyword">import</span> os
<span class="hljs-keyword">import</span> re

SCRIPT_CALLBACKS = [
    <span class="hljs-string">&quot;onUpdate&quot;</span>, <span class="hljs-string">&quot;afterUpdate&quot;</span>, <span class="hljs-string">&quot;onInit&quot;</span>, <span class="hljs-string">&quot;onDestroy&quot;</span>, <span class="hljs-string">&quot;onDraw&quot;</span>, <span class="hljs-string">&quot;onDraw2D&quot;</span>
]
</code></pre>
<p>Lets at least try to be pythonic and put the all of the script processing stuff in a <code>ScriptProcessor</code> class. We want to be able to specify all the paths etc rather than hardcoding so</p>
<pre><code class="language-python"><span class="hljs-comment"># processes all Flux scripts and creates `struct script`</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ScriptProcessor</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, project_path : <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;project&quot;</span>, scripts_folder : <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;scripts&quot;</span>, engine_path : <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;engine&quot;</span>, output_file : <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;GENERATED_SCRIPTS.h&quot;</span></span>):
    <span class="hljs-comment"># path of the project (where project_path/scripts is where all the scripts are)</span>
    self.project_path : <span class="hljs-built_in">str</span> = project_path
    <span class="hljs-comment"># name of the scripts folder</span>
    self.scripts_folder : <span class="hljs-built_in">str</span> = scripts_folder
    <span class="hljs-comment"># path of the scripts folder</span>
    self.scripts_path : <span class="hljs-built_in">str</span> = os.path.join(self.project_path,self.scripts_folder)
    <span class="hljs-comment"># path of the engine sources</span>
    self.engine_path : <span class="hljs-built_in">str</span> = engine_path
    <span class="hljs-comment"># name of the output scripts file</span>
    self.output_file : <span class="hljs-built_in">str</span> = output_file
    <span class="hljs-comment"># path of the output scripts file</span>
    self.output_path : <span class="hljs-built_in">str</span> = os.path.join(self.engine_path,output_file)
</code></pre>
<p>Now we need a way to find the scripts. We can do this with a disgusting one liner:</p>
<pre><code class="language-python"><span class="hljs-comment"># finds all `.c` files in `scripts_path`</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_scripts</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]:
    <span class="hljs-keyword">return</span> [os.path.join(self.scripts_path,i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> os.listdir(self.scripts_path) <span class="hljs-keyword">if</span> i.split(<span class="hljs-string">&quot;.&quot;</span>)[-<span class="hljs-number">1</span>].strip() == <span class="hljs-string">&quot;c&quot;</span>]
</code></pre>
<p>We might not want to implement all possible callbacks, so our script should figure out which callbacks we have implemented and auto generate the others. So</p>
<pre><code class="language-python"><span class="hljs-comment"># finds not implemented callbacks in a loaded script</span>
<span class="hljs-comment"># this just looks for instances of the callback name,</span>
<span class="hljs-comment"># SO, might get things wrong - be careful!</span>
<span class="hljs-comment"># should probably change this in the future, so</span>
<span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> fix me...</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">find_not_implemented</span>(<span class="hljs-params">self, raw : <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>]:
    <span class="hljs-keyword">return</span> [i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> SCRIPT_CALLBACKS <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> i <span class="hljs-keyword">in</span> raw]

<span class="hljs-comment"># given a callback name, return an empty `implementation`</span>
<span class="hljs-comment"># i.e., a function that doesn&#x27;t do anything</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_empty_implementation</span>(<span class="hljs-params">self,callback : <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;fluxCallback {0}(fluxGameObject obj, script_data* data){{}}&quot;</span>.<span class="hljs-built_in">format</span>(callback)

<span class="hljs-comment"># gets implementations for all not implemented callbacks</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">get_extra_implementations</span>(<span class="hljs-params">self, raw : <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\n&quot;</span>.join([self.get_empty_implementation(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.find_not_implemented(raw)])
</code></pre>
<p>We also want to be able to parse the name of this script (this is how we will identify the script in code in the engine etc.).</p>
<pre><code class="language-python"><span class="hljs-comment"># parses the script name from the raw text</span>
<span class="hljs-comment"># this is what SCRIPT is defined to at the start of the script,</span>
<span class="hljs-comment"># so we can do two simple `splits` and a strip to get it</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">parse_script_name</span>(<span class="hljs-params">self, raw : <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">str</span>:
    <span class="hljs-keyword">return</span> raw.split(<span class="hljs-string">&quot;#define SCRIPT&quot;</span>)[<span class="hljs-number">1</span>].split(<span class="hljs-string">&quot;\n&quot;</span>)[<span class="hljs-number">0</span>].strip()
</code></pre>
<p>We then have enough to write a simple script processor</p>
<pre><code class="language-python"><span class="hljs-comment"># processes a single script file</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">process_file</span>(<span class="hljs-params">self, path : <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(path,<span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:
        raw = f.read()
    raw += <span class="hljs-string">&quot;\n\n&quot;</span> + self.get_extra_implementations(raw) + <span class="hljs-string">&quot;\n\n&quot;</span>
    self.output += raw
    self.script_names.append(self.parse_script_name(raw))

<span class="hljs-comment"># process all scripts</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">process_scripts</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:
    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.scripts:
        self.process_file(i)
</code></pre>
<p>The init function then becomes</p>
<pre><code class="language-python"><span class="hljs-comment"># processes all Flux scripts and creates `struct script`</span>
<span class="hljs-keyword">class</span> <span class="hljs-title class_">ScriptProcessor</span>:
    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, project_path : <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;project&quot;</span>, scripts_folder : <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;scripts&quot;</span>, engine_path : <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;engine&quot;</span>, output_file : <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;GENERATED_SCRIPTS.h&quot;</span></span>):
        <span class="hljs-comment"># path of the project (where project_path/scripts is where all the scripts are)</span>
        self.project_path : <span class="hljs-built_in">str</span> = project_path
        <span class="hljs-comment"># name of the scripts folder</span>
        self.scripts_folder : <span class="hljs-built_in">str</span> = scripts_folder
        <span class="hljs-comment"># path of the scripts folder</span>
        self.scripts_path : <span class="hljs-built_in">str</span> = os.path.join(self.project_path,self.scripts_folder)
        <span class="hljs-comment"># path of the engine sources</span>
        self.engine_path : <span class="hljs-built_in">str</span> = engine_path
        <span class="hljs-comment"># name of the output scripts file</span>
        self.output_file : <span class="hljs-built_in">str</span> = output_file
        <span class="hljs-comment"># path of the output scripts file</span>
        self.output_path : <span class="hljs-built_in">str</span> = os.path.join(self.engine_path,output_file)
        <span class="hljs-comment"># list of all script files</span>
        self.scripts : <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = self.find_scripts()
        <span class="hljs-comment"># empty list of script names</span>
        <span class="hljs-comment"># when we process a script, we add the name of it to this list</span>
        self.script_names : <span class="hljs-built_in">list</span>[<span class="hljs-built_in">str</span>] = []
        <span class="hljs-comment"># the output generated file (initially empty)</span>
        self.output : <span class="hljs-built_in">str</span> = <span class="hljs-string">&#x27;#include &quot;gameobject.h&quot;\n#include &quot;sceneallocator.h&quot;\n&#x27;</span> + <span class="hljs-string">&quot;#ifdef FLUX_SCRIPTS_IMPLEMENTATION\n&quot;</span>
        <span class="hljs-comment"># now we can process all the scripts</span>
        self.process_scripts()
</code></pre>
<p>We want an enum to identify the scripts, so</p>
<pre><code class="language-python"><span class="hljs-comment"># generates `enum fluxScriptID`</span>
<span class="hljs-keyword">def</span> <span class="hljs-title function_">generate_enum_script_id</span>(<span class="hljs-params">self</span>):
    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;\nenum fluxScriptID{&quot;</span> + <span class="hljs-string">&quot;,&quot;</span>.join([get_script_enum_name(i) <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.script_names]) + <span class="hljs-string">&quot;};\n&quot;</span>
</code></pre>
<p><code>get_script_enum_name</code> is a function that mangles the script names into an enum. I am putting this in a separate file <code>pputils.py</code> because it will probably be useful in other preprocessing python scripts.</p>
<p>Ok, I'm getting bored. There are a bunch of other similar preprocessing functions that essentially do this:</p>
<ul>
<li>create a <code>fluxScript</code> data structure that is kind of a virtual class that contains all scripts.</li>
<li>we create a function to allocate a <code>fluxScript</code> given a <code>enum fluxScriptID</code>.</li>
<li>we then create functions for all the callbacks that operate on <code>fluxScript</code>s (so are ''generic'').</li>
</ul>
<p>At the end, the output from the python script looks something like:</p>
<pre><code class="language-c"><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_fluxData</span>;</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test2_fluxData</span>;</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gameobject.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sceneallocator.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCRIPT test</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fluxScript.h&quot;</span></span>

script_data{
    <span class="hljs-type">int</span> x;
};

fluxCallback <span class="hljs-title function_">onInit</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{
    data-&gt;x = <span class="hljs-number">0</span>;
}

fluxCallback <span class="hljs-title function_">onUpdate</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{
    data-&gt;x++;
}

fluxCallback <span class="hljs-title function_">afterUpdate</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{}
fluxCallback <span class="hljs-title function_">onDestroy</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{}
fluxCallback <span class="hljs-title function_">onDraw</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{}
fluxCallback <span class="hljs-title function_">onDraw2D</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{}

<span class="hljs-meta">#<span class="hljs-keyword">define</span> SCRIPT test2</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;fluxScript.h&quot;</span></span>

script_data{
    <span class="hljs-type">float</span> y;
};

fluxCallback <span class="hljs-title function_">onInit</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{
    data-&gt;y = <span class="hljs-number">0</span>;
}

fluxCallback <span class="hljs-title function_">onUpdate</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{}
fluxCallback <span class="hljs-title function_">afterUpdate</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{}
fluxCallback <span class="hljs-title function_">onDestroy</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{}
fluxCallback <span class="hljs-title function_">onDraw</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{}
fluxCallback <span class="hljs-title function_">onDraw2D</span><span class="hljs-params">(fluxGameObject obj, script_data* data)</span>{}
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fluxScriptID</span>{</span>fluxScript_test,fluxScript_test2};

<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fluxScriptStruct</span>;</span>
<span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fluxScriptStruct</span>* <span class="hljs-title">fluxScript</span>;</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fluxScriptStruct</span>{</span>
    <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">fluxScriptID</span> <span class="hljs-title">id</span>;</span>
    <span class="hljs-class"><span class="hljs-keyword">union</span> {</span>
        <span class="hljs-type">void</span>* raw;
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test_fluxData</span>* <span class="hljs-title">test_fluxData</span>;</span>
        <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">test2_fluxData</span>* <span class="hljs-title">test2_fluxData</span>;</span>
    };
};
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">fluxCallback_onUpdate</span><span class="hljs-params">(fluxGameObject obj, fluxScript script)</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
{
    <span class="hljs-keyword">switch</span>(script-&gt;id){
        <span class="hljs-keyword">case</span> fluxScript_test:
            test_fluxCallback_onUpdate(obj,script-&gt;test_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> fluxScript_test2:
            test2_fluxCallback_onUpdate(obj,script-&gt;test2_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            assert((<span class="hljs-number">1</span> == <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;something terrible happened at compile time!&quot;</span>);
            <span class="hljs-keyword">break</span>;
    }
}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">fluxCallback_afterUpdate</span><span class="hljs-params">(fluxGameObject obj, fluxScript script)</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
{
    <span class="hljs-keyword">switch</span>(script-&gt;id){
        <span class="hljs-keyword">case</span> fluxScript_test:
            test_fluxCallback_afterUpdate(obj,script-&gt;test_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> fluxScript_test2:
            test2_fluxCallback_afterUpdate(obj,script-&gt;test2_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            assert((<span class="hljs-number">1</span> == <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;something terrible happened at compile time!&quot;</span>);
            <span class="hljs-keyword">break</span>;
    }
}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">fluxCallback_onInit</span><span class="hljs-params">(fluxGameObject obj, fluxScript script)</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
{
    <span class="hljs-keyword">switch</span>(script-&gt;id){
        <span class="hljs-keyword">case</span> fluxScript_test:
            test_fluxCallback_onInit(obj,script-&gt;test_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> fluxScript_test2:
            test2_fluxCallback_onInit(obj,script-&gt;test2_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            assert((<span class="hljs-number">1</span> == <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;something terrible happened at compile time!&quot;</span>);
            <span class="hljs-keyword">break</span>;
    }
}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">fluxCallback_onDestroy</span><span class="hljs-params">(fluxGameObject obj, fluxScript script)</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
{
    <span class="hljs-keyword">switch</span>(script-&gt;id){
        <span class="hljs-keyword">case</span> fluxScript_test:
            test_fluxCallback_onDestroy(obj,script-&gt;test_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> fluxScript_test2:
            test2_fluxCallback_onDestroy(obj,script-&gt;test2_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            assert((<span class="hljs-number">1</span> == <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;something terrible happened at compile time!&quot;</span>);
            <span class="hljs-keyword">break</span>;
    }
}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">fluxCallback_onDraw</span><span class="hljs-params">(fluxGameObject obj, fluxScript script)</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
{
    <span class="hljs-keyword">switch</span>(script-&gt;id){
        <span class="hljs-keyword">case</span> fluxScript_test:
            test_fluxCallback_onDraw(obj,script-&gt;test_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> fluxScript_test2:
            test2_fluxCallback_onDraw(obj,script-&gt;test2_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            assert((<span class="hljs-number">1</span> == <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;something terrible happened at compile time!&quot;</span>);
            <span class="hljs-keyword">break</span>;
    }
}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

<span class="hljs-type">void</span> <span class="hljs-title function_">fluxCallback_onDraw2D</span><span class="hljs-params">(fluxGameObject obj, fluxScript script)</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
{
    <span class="hljs-keyword">switch</span>(script-&gt;id){
        <span class="hljs-keyword">case</span> fluxScript_test:
            test_fluxCallback_onDraw2D(obj,script-&gt;test_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> fluxScript_test2:
            test2_fluxCallback_onDraw2D(obj,script-&gt;test2_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            assert((<span class="hljs-number">1</span> == <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;something terrible happened at compile time!&quot;</span>);
            <span class="hljs-keyword">break</span>;
    }
}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>

fluxScript <span class="hljs-title function_">fluxAllocateScript</span><span class="hljs-params">(<span class="hljs-keyword">enum</span> fluxScriptID id)</span>
<span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
{
    fluxScript out = (fluxScript)flux_scene_alloc(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> fluxScriptStruct));
    out-&gt;id = id;
    <span class="hljs-type">size_t</span> sz = <span class="hljs-number">0</span>;
    <span class="hljs-keyword">switch</span>(id){
        <span class="hljs-keyword">case</span> fluxScript_test:
            sz = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> test_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">case</span> fluxScript_test2:
            sz = <span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> test2_fluxData);
            <span class="hljs-keyword">break</span>;
        <span class="hljs-keyword">default</span>:
            assert((<span class="hljs-number">1</span> == <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;something terrible happened at build time!&quot;</span>);
            <span class="hljs-keyword">break</span>;
    }
    out-&gt;raw = flux_scene_alloc(sz);
    <span class="hljs-keyword">return</span> out;
}
<span class="hljs-meta">#<span class="hljs-keyword">else</span></span>
;
<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>which we then implement like</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> FLUX_SCRIPTS_IMPLEMENTATION</span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;GENERATED_SCRIPTS.h&quot;</span></span>
</code></pre>
<p>in a separate compilation unit.</p>

            
            
        </body>
        </html>