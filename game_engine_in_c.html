<!DOCTYPE html>
        <html>
        <head>
            <meta charset="UTF-8">
            <title>Writing a Game Engine in C</title>
            <style>
/* From extension vscode.github */
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

.vscode-dark img[src$=\#gh-light-mode-only],
.vscode-light img[src$=\#gh-dark-mode-only],
.vscode-high-contrast:not(.vscode-high-contrast-light) img[src$=\#gh-light-mode-only],
.vscode-high-contrast-light img[src$=\#gh-dark-mode-only] {
	display: none;
}

</style>
            
        <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/markdown.css">
<link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Microsoft/vscode/extensions/markdown-language-features/media/highlight.css">
<style>
            body {
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe WPC', 'Segoe UI', system-ui, 'Ubuntu', 'Droid Sans', sans-serif;
                font-size: 14px;
                line-height: 1.6;
            }
        </style>
        <style>
.task-list-item {
    list-style-type: none;
}

.task-list-item-checkbox {
    margin-left: -20px;
    vertical-align: middle;
    pointer-events: none;
}
</style>
<style>
:root {
  --color-note: #0969da;
  --color-tip: #1a7f37;
  --color-warning: #9a6700;
  --color-severe: #bc4c00;
  --color-caution: #d1242f;
  --color-important: #8250df;
}

</style>
<style>
@media (prefers-color-scheme: dark) {
  :root {
    --color-note: #2f81f7;
    --color-tip: #3fb950;
    --color-warning: #d29922;
    --color-severe: #db6d28;
    --color-caution: #f85149;
    --color-important: #a371f7;
  }
}

</style>
<style>
.markdown-alert {
  padding: 0.5rem 1rem;
  margin-bottom: 16px;
  color: inherit;
  border-left: .25em solid #888;
}

.markdown-alert>:first-child {
  margin-top: 0
}

.markdown-alert>:last-child {
  margin-bottom: 0
}

.markdown-alert .markdown-alert-title {
  display: flex;
  font-weight: 500;
  align-items: center;
  line-height: 1
}

.markdown-alert .markdown-alert-title .octicon {
  margin-right: 0.5rem;
  display: inline-block;
  overflow: visible !important;
  vertical-align: text-bottom;
  fill: currentColor;
}

.markdown-alert.markdown-alert-note {
  border-left-color: var(--color-note);
}

.markdown-alert.markdown-alert-note .markdown-alert-title {
  color: var(--color-note);
}

.markdown-alert.markdown-alert-important {
  border-left-color: var(--color-important);
}

.markdown-alert.markdown-alert-important .markdown-alert-title {
  color: var(--color-important);
}

.markdown-alert.markdown-alert-warning {
  border-left-color: var(--color-warning);
}

.markdown-alert.markdown-alert-warning .markdown-alert-title {
  color: var(--color-warning);
}

.markdown-alert.markdown-alert-tip {
  border-left-color: var(--color-tip);
}

.markdown-alert.markdown-alert-tip .markdown-alert-title {
  color: var(--color-tip);
}

.markdown-alert.markdown-alert-caution {
  border-left-color: var(--color-caution);
}

.markdown-alert.markdown-alert-caution .markdown-alert-title {
  color: var(--color-caution);
}

</style>
        
        </head>
        <body class="vscode-body vscode-light">
            <h1 id="writing-a-game-engine-in-c">Writing a Game Engine in C</h1>
<p>This is a kind of unstructured log of the process of writing a game engine in C, using <a href="https://www.raylib.com/">raylib</a> as the backend. As a disclaimer, I have no idea what I am doing or what best practices are.</p>
<h2 id="day-1-allocator">Day 1: Allocator</h2>
<p>The first thing we need to do is figure out how the game engine is going to be structured.</p>
<p>My initial thoughts are:</p>
<ul>
<li>We divide the game into 'scenes', which are loaded and unloaded according to some logic (like when a user presses the 'level 0' button, we load the level 0 scene).</li>
<li>Each scene contains a number of 'prefabs'. When we load a scene, we 'instantiate' these prefabs into game objects, which are the entities in the scene. This is also nice because then we can instantiate more prefabs while the scene is going.</li>
<li>Each prefab contains some information - the initial transform of the entity, whether it has a model, what the path to the model is etc.. We use this information to construct an independent GameObject.</li>
<li>Each prefab (and thus GameObject) has some 'scripts' associated with it. These scripts function like callbacks (? terminology confusing idk if I am using that right), in the sense that each script can implement, for example, an <code>onUpdate</code> function that is called every frame, or an <code>onInit</code> function that is called on GameObject creation.</li>
</ul>
<p>This is a nice rough idea of how we want things to be structured. One thing that would be nice though is to be able to allocate memory/load models etc. that are automatically freed/unloaded when the current scene is closed. We are going to need to load models/allocate memory for GameObjects whenever a scene is loaded, and we only want to free/unload them when the scene is closed.</p>
<p>So the first bit of code we can write is a simple allocator that keeps track of memory allocations/loaded models.</p>
<p>This is the interface I went with (in <code>sceneallocator.h</code>):</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">ifndef</span> _FLUX_SCENEALLOCATOR_H_</span>
<span class="hljs-meta">#<span class="hljs-keyword">define</span> _FLUX_SCENEALLOCATOR_H_</span>

<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;raylib.h&quot;</span></span>

<span class="hljs-comment">// initializes the scene allocator for the current scene (so should be called every scene load)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">flux_init_scene_allocator</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;

<span class="hljs-comment">// closes the scene allocator for the current scene (so should be called every scene close)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">flux_close_scene_allocator</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>;

<span class="hljs-comment">// allocates some heap space that will be cleared on scene close</span>
<span class="hljs-type">void</span>* <span class="hljs-title function_">flux_scene_alloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> sz)</span>;

<span class="hljs-comment">// loads a model that will be cleared on scene close</span>
Model <span class="hljs-title function_">flux_scene_load_model</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>;

<span class="hljs-meta">#<span class="hljs-keyword">endif</span></span>
</code></pre>
<p>So, we would call <code>flux_init_scene_allocator</code> whenever we load a scene, and <code>flux_close_scene_allocator</code> whenever we close a scene. Then, we can use <code>flux_scene_alloc</code> and <code>flux_scene_load_model</code> to allocate memory/load models without having to worry about unloading/freeing (because this is done in <code>flux_close_scene_allocator</code>).</p>
<p>The implementation is fairly simple. We store allocations and models in contiguous arrays. So, in <code>sceneallocator.c</code>:</p>
<pre><code class="language-c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;assert.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;raylib.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;raymath.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;gameobject.h&quot;</span></span>
<span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;sceneallocator.h&quot;</span></span>

<span class="hljs-comment">// stores all the allocations of the current scene in resizable array</span>
<span class="hljs-type">static</span> <span class="hljs-type">void</span>** allocations = <span class="hljs-literal">NULL</span>;
<span class="hljs-comment">// number of active allocations</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> n_allocations = <span class="hljs-number">0</span>;
<span class="hljs-comment">// size of the allocations array (n_allocations may be less than allocations_size)</span>
<span class="hljs-type">static</span> <span class="hljs-type">int</span> allocations_size = <span class="hljs-number">0</span>;

<span class="hljs-comment">// similarly for models</span>
<span class="hljs-type">static</span> Model* models = <span class="hljs-literal">NULL</span>;
<span class="hljs-type">static</span> <span class="hljs-type">int</span> n_models = <span class="hljs-number">0</span>;
<span class="hljs-type">static</span> <span class="hljs-type">int</span> models_size = <span class="hljs-number">0</span>;
</code></pre>
<p>This lets us write hacky hardcoded grow-able arrays for allocations and models. It would probably be smart to write a general resizable array at some point, because we will want to be able to load shaders/textures etc in the same way.</p>
<p>First we implement <code>flux_init_scene_allocator</code>. I will probably want to clean this up in the future, but this works for now:</p>
<pre><code class="language-c"><span class="hljs-comment">// initializes the scene allocator for the current scene (so should be called every scene load)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">flux_init_scene_allocator</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
    <span class="hljs-comment">// allocations and models must be NULL</span>
    <span class="hljs-comment">// if not, then something bad happened</span>
    assert((<span class="hljs-literal">NULL</span> == allocations) &amp;&amp; (<span class="hljs-literal">NULL</span> == models) &amp;&amp; <span class="hljs-string">&quot;was fluxCloseSceneAllocator called on scene close?&quot;</span>);
    <span class="hljs-comment">// set number of allocations and models to 0</span>
    n_allocations = <span class="hljs-number">0</span>;
    n_models = <span class="hljs-number">0</span>;
    <span class="hljs-comment">// and the initial size of the allocations and models arrays to be 10</span>
    allocations_size = <span class="hljs-number">10</span>;
    models_size = <span class="hljs-number">10</span>;
    <span class="hljs-comment">// malloc accordingly</span>
    assert(allocations = (<span class="hljs-type">void</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span>*) * allocations_size));
    assert(models = (<span class="hljs-type">void</span>**)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(Model) * models_size));
}
</code></pre>
<p>For <code>flux_close_scene_allocator</code> we want to free all the allocations and models by looping through the active allocations/models:</p>
<pre><code class="language-c"><span class="hljs-comment">// closes the scene allocator for the current scene (so should be called every scene close)</span>
<span class="hljs-type">void</span> <span class="hljs-title function_">flux_close_scene_allocator</span><span class="hljs-params">(<span class="hljs-type">void</span>)</span>{
    assert((n_allocations &gt;= <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;n_allocations was less than 0???&quot;</span>);
    assert((n_allocations &lt; allocations_size) &amp;&amp; <span class="hljs-string">&quot;n_allocations is less than allocations_size!&quot;</span>);
    assert((n_models &gt;= <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;n_models was less than 0???&quot;</span>);
    assert((n_models &lt; models_size) &amp;&amp; <span class="hljs-string">&quot;n_models is less than models_size!&quot;</span>);
    <span class="hljs-comment">// loop through active allocations and free the memory</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n_allocations; i++){
        <span class="hljs-built_in">free</span>(allocations[i]);
    }
    <span class="hljs-comment">// finally free the allocations array and set to NULL</span>
    <span class="hljs-built_in">free</span>(allocations); allocations = <span class="hljs-literal">NULL</span>;
    <span class="hljs-comment">// loop through active models and free the Model</span>
    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n_models; i++){
        UnloadModel(models[i]);
    }
    <span class="hljs-built_in">free</span>(models); models = <span class="hljs-literal">NULL</span>;
}
</code></pre>
<p>Finally, for the allocation and model loading methods, we do the hacky hardcoded grow-able array stuff:</p>
<pre><code class="language-c"><span class="hljs-comment">// allocates some heap space that will be cleared on scene close</span>
<span class="hljs-type">void</span>* <span class="hljs-title function_">flux_scene_alloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> sz)</span>{
    assert((n_allocations &gt;= <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;n_allocations was less than 0???&quot;</span>);
    <span class="hljs-comment">// if we are out of space, we must grow the array</span>
    <span class="hljs-keyword">if</span> (n_allocations &gt;= allocations_size){
        assert((allocations_size &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;allocations_size should never be less than 1!&quot;</span>);
        <span class="hljs-comment">// double the size of the allocations array</span>
        allocations_size *= <span class="hljs-number">2</span>;
        <span class="hljs-comment">// realloc accordingly</span>
        assert(allocations = <span class="hljs-built_in">realloc</span>(allocations,<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">void</span>*) * allocations_size));
        assert((n_allocations &lt; allocations_size) &amp;&amp; <span class="hljs-string">&quot;n_allocations was still bigger than allocations_size after resize!&quot;</span>);
    }
    <span class="hljs-comment">// get the pointer to be returned</span>
    <span class="hljs-type">void</span>* out; assert(out = (<span class="hljs-type">void</span>*)<span class="hljs-built_in">malloc</span>(sz));
    <span class="hljs-comment">// store this pointer in the correct place in allocations</span>
    allocations[n_allocations] = out;
    <span class="hljs-comment">// and then increment n_allocations</span>
    n_allocations++;
    <span class="hljs-comment">// finally return the malloced data</span>
    <span class="hljs-keyword">return</span> out;
}

Model <span class="hljs-title function_">flux_scene_load_model</span><span class="hljs-params">(<span class="hljs-type">const</span> <span class="hljs-type">char</span>* path)</span>{
    assert((n_models &gt;= <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;n_models was less than 0???&quot;</span>);
    <span class="hljs-comment">// if we are out of space, we must grow the array</span>
    <span class="hljs-keyword">if</span> (n_models &gt;= models_size){
        assert((models_size &gt; <span class="hljs-number">0</span>) &amp;&amp; <span class="hljs-string">&quot;models_size should never be less than 1!&quot;</span>);
        <span class="hljs-comment">// double the size of the models array</span>
        models_size *= <span class="hljs-number">2</span>;
        <span class="hljs-comment">// realloc accordingly</span>
        assert(models = <span class="hljs-built_in">realloc</span>(models,<span class="hljs-keyword">sizeof</span>(Model) * models_size));
        assert((n_models &lt; models_size) &amp;&amp; <span class="hljs-string">&quot;n_models was still bigger than models_size after resize!&quot;</span>);
    }
    <span class="hljs-comment">// get the model to be returned</span>
    Model out = LoadModel(path);
    <span class="hljs-comment">// store this model in the correct place in models</span>
    models[n_models] = out;
    <span class="hljs-comment">// and then increment n_models</span>
    n_models++;
    <span class="hljs-comment">// finally return the loaded model</span>
    <span class="hljs-keyword">return</span> out;
}
</code></pre>
<p>Next up: Prefabs and GameObjects!</p>

            
            
        </body>
        </html>